/**
 * XML Serialization/Deserialization utilities for BehaviorTree.cpp format
 * 
 * This module handles conversion between the editor's internal format and
 * BehaviorTree.cpp XML format. It's designed to be modular for future updates.
 * 
 * Supports multi-tree files where a main tree and subtrees are stored together.
 */

import type { Node as FlowNode, Edge } from 'reactflow';
import { Variable, SubTreePort } from '../types';

// Alias to avoid conflict with DOM Node
type Node = FlowNode;

interface SerializationOptions {
  formatOutput?: boolean;
  includeComments?: boolean;
}

/**
 * Represents a single BehaviorTree within a file
 */
export interface TreeData {
  id: string;
  nodes: Node[];
  edges: Edge[];
  variables: Variable[];
  description?: string; // Optional description for subtrees
  ports?: SubTreePort[]; // Input/output ports for subtrees
}

/** The ID used for the main/parent tree that BehaviorTree.cpp executes */
export const MAIN_TREE_ID = 'main_tree_to_execute';

/**
 * Result of parsing a multi-tree XML file
 */
export interface MultiTreeParseResult {
  mainTree: TreeData;
  subtrees: Map<string, TreeData>;
  treeOrder: string[]; // Preserves order of trees in file
}

/**
 * Export a behavior tree to BehaviorTree.cpp XML format
 */
export function exportToXML(
  nodes: Node[],
  edges: Edge[],
  variables: Variable[],
  treeId: string = 'MainTree',
  options: SerializationOptions = {}
): string {
  const { formatOutput = true, includeComments = true } = options;

  // Build tree structure from nodes and edges
  const treeStructure = buildTreeStructure(nodes, edges);
  
  // Generate XML
  let xml = '<?xml version="1.0"?>\n';
  xml += `<root BTCPP_format="4" main_tree_to_execute="${escapeXML(treeId)}">\n`;
  
  if (includeComments) {
    xml += '  <!-- Generated by BTstudio -->\n\n';
  }
  
  // Add BehaviorTree element with tree ID
  xml += `  <BehaviorTree ID="${escapeXML(treeId)}">\n`;
  xml += serializeNodeRecursive(treeStructure.root, nodes, edges, variables, 2);
  xml += '  </BehaviorTree>\n';
  
  xml += '</root>';
  
  return formatOutput ? xml : xml.replace(/\n\s*/g, '');
}

/**
 * Export multiple trees to a single BehaviorTree.cpp XML file
 * Used for self-contained tree files with embedded subtrees
 */
export function exportMultiTreeToXML(
  mainTree: TreeData,
  subtrees: Map<string, TreeData>,
  options: SerializationOptions = {}
): string {
  const { formatOutput = true, includeComments = true } = options;
  
  let xml = '<?xml version="1.0"?>\n';
  xml += `<root BTCPP_format="4" main_tree_to_execute="${escapeXML(mainTree.id)}">\n`;
  
  if (includeComments) {
    xml += '  <!-- Generated by BTstudio -->\n\n';
  }
  
  // Serialize main tree first
  xml += `  <BehaviorTree ID="${escapeXML(mainTree.id)}">\n`;
  const mainTreeStructure = buildTreeStructure(mainTree.nodes, mainTree.edges);
  xml += serializeNodeRecursive(mainTreeStructure.root, mainTree.nodes, mainTree.edges, mainTree.variables, 2);
  xml += '  </BehaviorTree>\n\n';
  
  // Serialize each subtree
  subtrees.forEach((subtreeData, subtreeId) => {
    // Write description as comment (not parsed by BT server)
    if (subtreeData.description) {
      xml += `  <!-- ${escapeXML(subtreeData.description)} -->\n`;
    }
    xml += `  <BehaviorTree ID="${escapeXML(subtreeId)}">`;
    xml += `\n`;
    const subtreeStructure = buildTreeStructure(subtreeData.nodes, subtreeData.edges);
    xml += serializeNodeRecursive(subtreeStructure.root, subtreeData.nodes, subtreeData.edges, subtreeData.variables, 2);
    xml += '  </BehaviorTree>\n\n';
  });
  
  // Serialize TreeNodesModel for subtrees with ports
  xml += serializeTreeNodesModel(subtrees);
  
  xml += '</root>';
  
  return formatOutput ? xml : xml.replace(/\n\s*/g, '');
}

/**
 * Export only the subtree library file (contains just subtree definitions)
 */
export function exportSubtreeLibraryToXML(
  subtrees: Map<string, TreeData>,
  options: SerializationOptions = {}
): string {
  const { formatOutput = true, includeComments = true } = options;
  
  let xml = '<?xml version="1.0"?>\n';
  xml += '<root BTCPP_format="4">\n';
  
  if (includeComments) {
    xml += '  <!-- BTstudio Subtree Library -->\n\n';
  }
  
  // Serialize each subtree
  subtrees.forEach((subtreeData, subtreeId) => {
    // Write description as comment (not parsed by BT server)
    if (subtreeData.description) {
      xml += `  <!-- ${escapeXML(subtreeData.description)} -->\n`;
    }
    xml += `  <BehaviorTree ID="${escapeXML(subtreeId)}">\n`;
    const subtreeStructure = buildTreeStructure(subtreeData.nodes, subtreeData.edges);
    xml += serializeNodeRecursive(subtreeStructure.root, subtreeData.nodes, subtreeData.edges, subtreeData.variables, 2);
    xml += '  </BehaviorTree>\n\n';
  });
  
  // Serialize TreeNodesModel for all subtrees with ports
  xml += serializeTreeNodesModel(subtrees);
  
  xml += '</root>';
  
  return formatOutput ? xml : xml.replace(/\n\s*/g, '');
}

/**
 * Serialize TreeNodesModel section for subtree port definitions
 */
function serializeTreeNodesModel(subtrees: Map<string, TreeData>): string {
  // Collect all subtrees that have ports defined
  const subtreesWithPorts: TreeData[] = [];
  subtrees.forEach((treeData) => {
    if (treeData.ports && treeData.ports.length > 0) {
      subtreesWithPorts.push(treeData);
    }
  });
  
  if (subtreesWithPorts.length === 0) {
    return '';
  }
  
  let xml = '  <!-- Subtree port definitions -->\n';
  xml += '  <TreeNodesModel>\n';
  
  subtreesWithPorts.forEach((treeData) => {
    xml += `    <SubTree ID="${escapeXML(treeData.id)}">\n`;
    
    treeData.ports!.forEach((port) => {
      const defaultAttr = port.defaultValue ? ` default="${escapeXML(port.defaultValue)}"` : '';
      const typeAttr = port.type ? ` type="${port.type}"` : '';
      const reqAttr = port.required ? ' required="true"' : '';
      const desc = port.description ? escapeXML(port.description) : '';
      
      if (port.direction === 'input') {
        xml += `      <input_port name="${escapeXML(port.name)}"${typeAttr}${defaultAttr}${reqAttr}>${desc}</input_port>\n`;
      } else if (port.direction === 'output') {
        xml += `      <output_port name="${escapeXML(port.name)}"${typeAttr}${defaultAttr}${reqAttr}>${desc}</output_port>\n`;
      } else {
        xml += `      <inout_port name="${escapeXML(port.name)}"${typeAttr}${defaultAttr}${reqAttr}>${desc}</inout_port>\n`;
      }
    });
    
    xml += '    </SubTree>\n';
  });
  
  xml += '  </TreeNodesModel>\n\n';
  
  return xml;
}

/**
 * Import a BehaviorTree.cpp XML format tree into editor format
 * For single-tree files (backward compatibility)
 */
export function importFromXML(xmlString: string): {
  nodes: Node[];
  edges: Edge[];
  variables: Variable[];
} {
  const result = importMultiTreeFromXML(xmlString);
  return {
    nodes: result.mainTree.nodes,
    edges: result.mainTree.edges,
    variables: result.mainTree.variables,
  };
}

/**
 * Import a multi-tree BehaviorTree.cpp XML file
 * Returns the main tree (first BehaviorTree) and all subtrees
 */
export function importMultiTreeFromXML(xmlString: string): MultiTreeParseResult {
  const parser = new DOMParser();
  const xmlDoc = parser.parseFromString(xmlString, 'text/xml');
  
  // Check for parsing errors
  const parseError = xmlDoc.querySelector('parsererror');
  if (parseError) {
    throw new Error('Invalid XML: ' + parseError.textContent);
  }
  
  const root = xmlDoc.querySelector('root');
  if (!root) {
    throw new Error('Invalid BehaviorTree XML: missing root element');
  }
  
  // Get main_tree_to_execute attribute to identify which tree is the main one
  const mainTreeId = root.getAttribute('main_tree_to_execute');
  
  // Get ALL BehaviorTree elements
  const behaviorTrees = root.querySelectorAll('BehaviorTree');
  if (behaviorTrees.length === 0) {
    throw new Error('Invalid BehaviorTree XML: missing BehaviorTree element');
  }
  
  const subtrees = new Map<string, TreeData>();
  const treeOrder: string[] = [];
  let mainTree: TreeData | null = null;
  
  // Build a map of tree IDs to their preceding comment (description)
  const descriptionMap = new Map<string, string>();
  let currentComment: string | null = null;
  
  // Walk through root's child nodes to find comments preceding BehaviorTree elements
  // Using numeric nodeType values: 8=COMMENT_NODE, 1=ELEMENT_NODE
  root.childNodes.forEach((node) => {
    if (node.nodeType === 8) { // COMMENT_NODE
      // Store comment text, stripping whitespace
      currentComment = (node.textContent || '').trim();
    } else if (node.nodeType === 1 && (node as Element).tagName === 'BehaviorTree') { // ELEMENT_NODE
      const treeId = (node as Element).getAttribute('ID');
      if (treeId && currentComment) {
        // Exclude generated comments like "Generated by BTstudio"
        if (!currentComment.toLowerCase().includes('generated by') && 
            !currentComment.toLowerCase().includes('subtree library') &&
            !currentComment.toLowerCase().includes('port definitions')) {
          descriptionMap.set(treeId, currentComment);
        }
      }
      currentComment = null; // Reset after each BehaviorTree
    } else if (node.nodeType === 1) { // ELEMENT_NODE
      currentComment = null; // Reset if we encounter other elements
    }
  });
  
  // Parse each BehaviorTree element
  behaviorTrees.forEach((btElement, index) => {
    const treeId = btElement.getAttribute('ID') || `Tree_${index}`;
    // Look for description in comment map first, fall back to attribute for compatibility
    const description = descriptionMap.get(treeId) || btElement.getAttribute('description') || undefined;
    treeOrder.push(treeId);
    
    // Determine if this is the main tree:
    // 1. If main_tree_to_execute attr matches this tree's ID
    // 2. Or if main_tree_to_execute attr is absent and this is the first tree
    // 3. Or for backward compatibility if ID is "main_tree_to_execute"
    const isMainTree = (mainTreeId && treeId === mainTreeId) || 
                       (!mainTreeId && index === 0) ||
                       treeId === MAIN_TREE_ID;
    
    // Extract variables from this tree
    const variables: Variable[] = [];
    const firstSetBlackboardPerVariable = new Map<string, Element>();
    
    // Find SetBlackboard nodes for variable extraction
    const findSetBlackboardNodes = (element: Element) => {
      if (element.tagName === 'SetBlackboard') {
        const outputKey = element.getAttribute('output_key');
        if (outputKey && !firstSetBlackboardPerVariable.has(outputKey)) {
          firstSetBlackboardPerVariable.set(outputKey, element);
        }
      }
      Array.from(element.children).forEach(child => findSetBlackboardNodes(child));
    };
    findSetBlackboardNodes(btElement);
    
    // Parse the tree structure
    const { nodes, edges } = parseTreeStructure(btElement, variables, firstSetBlackboardPerVariable);
    
    const treeData: TreeData = {
      id: treeId,
      nodes,
      edges,
      variables,
      description,
    };
    
    // Use isMainTree to determine if this is the main tree
    if (isMainTree && !mainTree) {
      mainTree = treeData;
    } else {
      subtrees.set(treeId, treeData);
    }
  });
  
  if (!mainTree) {
    throw new Error('Failed to parse main tree');
  }
  
  // Parse TreeNodesModel for port definitions
  const portDefinitions = parseTreeNodesModel(root);
  
  // Attach ports to subtrees
  portDefinitions.forEach((ports, subtreeId) => {
    const subtree = subtrees.get(subtreeId);
    if (subtree) {
      subtree.ports = ports;
    }
  });
  
  return { mainTree, subtrees, treeOrder };
}

/**
 * Parse a subtree library file and return all subtree definitions
 */
export function importSubtreeLibraryFromXML(xmlString: string): Map<string, TreeData> {
  const parser = new DOMParser();
  const xmlDoc = parser.parseFromString(xmlString, 'text/xml');
  
  const parseError = xmlDoc.querySelector('parsererror');
  if (parseError) {
    throw new Error('Invalid XML: ' + parseError.textContent);
  }
  
  const root = xmlDoc.querySelector('root');
  if (!root) {
    // Return empty map for empty/invalid library files
    return new Map();
  }
  
  const behaviorTrees = root.querySelectorAll('BehaviorTree');
  const subtrees = new Map<string, TreeData>();
  
  // Build a map of tree IDs to their preceding comment (description)
  const descriptionMap = new Map<string, string>();
  let currentComment: string | null = null;
  
  // Using numeric nodeType values: 8=COMMENT_NODE, 1=ELEMENT_NODE
  root.childNodes.forEach((node) => {
    if (node.nodeType === 8) { // COMMENT_NODE
      currentComment = (node.textContent || '').trim();
    } else if (node.nodeType === 1 && (node as Element).tagName === 'BehaviorTree') { // ELEMENT_NODE
      const treeId = (node as Element).getAttribute('ID');
      if (treeId && currentComment) {
        if (!currentComment.toLowerCase().includes('generated by') && 
            !currentComment.toLowerCase().includes('subtree library') &&
            !currentComment.toLowerCase().includes('port definitions')) {
          descriptionMap.set(treeId, currentComment);
        }
      }
      currentComment = null;
    } else if (node.nodeType === 1) { // ELEMENT_NODE
      currentComment = null;
    }
  });
  
  behaviorTrees.forEach((btElement, index) => {
    const treeId = btElement.getAttribute('ID') || `SubTree_${index}`;
    const description = descriptionMap.get(treeId) || btElement.getAttribute('description') || undefined;
    
    const variables: Variable[] = [];
    const firstSetBlackboardPerVariable = new Map<string, Element>();
    
    const findSetBlackboardNodes = (element: Element) => {
      if (element.tagName === 'SetBlackboard') {
        const outputKey = element.getAttribute('output_key');
        if (outputKey && !firstSetBlackboardPerVariable.has(outputKey)) {
          firstSetBlackboardPerVariable.set(outputKey, element);
        }
      }
      Array.from(element.children).forEach(child => findSetBlackboardNodes(child));
    };
    findSetBlackboardNodes(btElement);
    
    const { nodes, edges } = parseTreeStructure(btElement, variables, firstSetBlackboardPerVariable);
    
    subtrees.set(treeId, {
      id: treeId,
      nodes,
      edges,
      variables,
      description,
    });
  });
  
  // Parse TreeNodesModel for port definitions
  const portDefinitions = parseTreeNodesModel(root);
  
  // Attach ports to subtrees
  portDefinitions.forEach((ports, subtreeId) => {
    const subtree = subtrees.get(subtreeId);
    if (subtree) {
      subtree.ports = ports;
    }
  });
  
  return subtrees;
}

/**
 * Get list of subtree IDs referenced in a tree
 */
export function getReferencedSubtreeIds(nodes: Node[]): string[] {
  const subtreeIds: string[] = [];
  
  nodes.forEach(node => {
    if (node.data?.category === 'subtree') {
      const subtreeId = node.data.subtreeId || node.data.type;
      if (subtreeId && !subtreeIds.includes(subtreeId)) {
        subtreeIds.push(subtreeId);
      }
    }
  });
  
  return subtreeIds;
}

/**
 * Update a specific subtree within an existing XML string
 * Used for efficiently updating other workspace files without full re-parse
 */
export function updateSubtreeInXML(
  xmlString: string,
  subtreeId: string,
  newSubtreeData: TreeData
): string {
  const parser = new DOMParser();
  const xmlDoc = parser.parseFromString(xmlString, 'text/xml');
  
  const root = xmlDoc.querySelector('root');
  if (!root) return xmlString;
  
  // Find the existing subtree element
  const behaviorTrees = root.querySelectorAll('BehaviorTree');
  let targetElement: Element | null = null;
  
  behaviorTrees.forEach(bt => {
    if (bt.getAttribute('ID') === subtreeId) {
      targetElement = bt;
    }
  });
  
  // Serialize the new subtree content
  const subtreeStructure = buildTreeStructure(newSubtreeData.nodes, newSubtreeData.edges);
  const newContent = serializeNodeRecursive(
    subtreeStructure.root,
    newSubtreeData.nodes,
    newSubtreeData.edges,
    newSubtreeData.variables,
    2
  );
  
  if (targetElement !== null) {
    // Replace existing subtree content
    (targetElement as Element).innerHTML = newContent;
  } else {
    // Add new subtree before closing </root>
    const newBT = xmlDoc.createElement('BehaviorTree');
    newBT.setAttribute('ID', subtreeId);
    newBT.innerHTML = newContent;
    root.appendChild(newBT);
  }
  
  // Serialize back to string
  const serializer = new XMLSerializer();
  let result = serializer.serializeToString(xmlDoc);
  
  // Fix formatting (XMLSerializer doesn't format nicely)
  result = result.replace(/><BehaviorTree/g, '>\n\n  <BehaviorTree');
  result = result.replace(/<\/BehaviorTree><\/root>/g, '</BehaviorTree>\n</root>');
  
  return result;
}

/**
 * Build a hierarchical tree structure from flat nodes/edges
 */
function buildTreeStructure(nodes: Node[], edges: Edge[]): {
  root: Node | null;
  childrenMap: Map<string, string[]>;
} {
  // Find root node
  const root = nodes.find(n => n.data?.category === 'root');
  
  // Build parent -> children map
  const childrenMap = new Map<string, string[]>();
  
  edges.forEach(edge => {
    const children = childrenMap.get(edge.source) || [];
    children.push(edge.target);
    childrenMap.set(edge.source, children);
  });
  
  // Sort children by their visual position (left to right)
  childrenMap.forEach((children, parent) => {
    children.sort((a, b) => {
      const nodeA = nodes.find(n => n.id === a);
      const nodeB = nodes.find(n => n.id === b);
      return (nodeA?.position?.x || 0) - (nodeB?.position?.x || 0);
    });
  });
  
  return { root: root || null, childrenMap };
}

/**
 * Serialize a node and its children recursively
 */
function serializeNodeRecursive(
  node: Node | null,
  nodes: Node[],
  edges: Edge[],
  variables: Variable[],
  indentLevel: number
): string {
  if (!node) return '';
  
  const indent = '  '.repeat(indentLevel);
  const { data } = node;
  
  // Skip the root node itself, just serialize its children
  if (data?.category === 'root') {
    const children = getNodeChildren(node.id, nodes, edges);
    if (children.length === 0) return '';
    
    // Root should have exactly one child
    const child = children[0];
    return serializeNodeRecursive(child, nodes, edges, variables, indentLevel);
  }
  
  // Handle SubTree nodes differently
  if (data?.category === 'subtree') {
    return serializeSubTreeNode(node, indentLevel);
  }
  
  // Regular node serialization
  const nodeType = data?.type || 'Unknown';
  
  // Convert DeclareVariable to SetBlackboard for export
  const exportNodeType = nodeType === 'DeclareVariable' ? 'SetBlackboard' : nodeType;
  
  const fields = data?.fields || [];
  const nodeName = data?.nodeName;
  
  // Build attributes string from fields
  const attributes: string[] = [];
  
  // Add name attribute first if it exists (BehaviorTree.cpp convention)
  if (nodeName) {
    attributes.push(`name="${escapeXML(nodeName)}"`);
  }
  
  fields.forEach((field: any) => {
    let fieldValue = field.value;
    
    // Strip brackets from output_key for SetBlackboard/DeclareVariable
    // They are stored with brackets for display but should be exported without
    if (field.name === 'output_key' && typeof fieldValue === 'string') {
      fieldValue = fieldValue.replace(/^\{|\}$/g, '');
    }
    
    if (field.valueType === 'variable') {
      // Variable reference: use {varName} syntax
      attributes.push(`${field.name}="{${fieldValue}}"`);
    } else {
      // Literal value
      attributes.push(`${field.name}="${escapeXML(String(fieldValue))}"`);
    }
  });
  
  const attrsString = attributes.length > 0 ? ' ' + attributes.join(' ') : '';
  
  // Get children
  const children = getNodeChildren(node.id, nodes, edges);
  
  if (children.length === 0) {
    // Self-closing tag for leaf nodes
    return `${indent}<${exportNodeType}${attrsString}/>\n`;
  } else {
    // Node with children
    let xml = `${indent}<${exportNodeType}${attrsString}>\n`;
    children.forEach(child => {
      xml += serializeNodeRecursive(child, nodes, edges, variables, indentLevel + 1);
    });
    xml += `${indent}</${exportNodeType}>\n`;
    return xml;
  }
}

/**
 * Serialize a SubTree node
 */
function serializeSubTreeNode(node: Node, indentLevel: number): string {
  const indent = '  '.repeat(indentLevel);
  const { data } = node;
  
  const subtreeId = data?.subtreeId || data?.type || 'UnnamedSubTree';
  const fields = data?.fields || [];
  const nodeName = data?.nodeName;
  
  // Build attributes for port mappings
  const attributes: string[] = [];
  
  // Add name attribute first if it exists
  if (nodeName) {
    attributes.push(`name="${escapeXML(nodeName)}"`);
  }
  
  // Map fields to ports
  fields.forEach((field: any) => {
    if (field.valueType === 'variable') {
      attributes.push(`${field.name}="{${field.value}}"`);
    } else {
      attributes.push(`${field.name}="${escapeXML(String(field.value))}"`);
    }
  });
  
  const attrsString = attributes.length > 0 ? ' ' + attributes.join(' ') : '';
  
  return `${indent}<SubTree ID="${subtreeId}"${attrsString}/>\n`;
}

/**
 * Get children nodes for a given parent node ID
 */
function getNodeChildren(nodeId: string, nodes: Node[], edges: Edge[]): Node[] {
  const childIds = edges
    .filter(e => e.source === nodeId)
    .map(e => e.target);
  
  const children = childIds
    .map(id => nodes.find(n => n.id === id))
    .filter((n): n is Node => n !== undefined);
  
  // Sort by x position
  children.sort((a, b) => (a.position?.x || 0) - (b.position?.x || 0));
  
  return children;
}

/**
 * Parse XML tree structure into nodes and edges
 */
function parseTreeStructure(
  behaviorTreeElement: Element,
  variables: Variable[],
  firstSetBlackboardPerVariable: Map<string, Element>
): {
  nodes: Node[];
  edges: Edge[];
} {
  const nodes: Node[] = [];
  const edges: Edge[] = [];
  
  // Create root node
  const rootNode: Node = {
    id: 'root_node',
    type: 'btNode',
    position: { x: 250, y: 50 },
    data: {
      id: 'root',
      type: 'Root',
      category: 'root',
      name: 'Root',
      description: 'Root node of the behavior tree',
      fields: [],
      instanceId: 'root_node',
      color: '#F44336',
    },
  };
  nodes.push(rootNode);
  
  // Parse child nodes
  let yPosition = 150;
  let xPosition = 250;
  
  const firstChild = behaviorTreeElement.children[0];
  if (firstChild) {
    const result = parseNodeRecursive(
      firstChild,
      xPosition,
      yPosition,
      0,
      variables,
      firstSetBlackboardPerVariable
    );
    
    if (result.node) {
      nodes.push(result.node);
      nodes.push(...result.allNodes.filter(n => n.id !== result.node!.id)); // Add all descendant nodes
      edges.push({
        id: `root_node-${result.node.id}`,
        source: 'root_node',
        target: result.node.id,
      });
      
      edges.push(...result.edges);
    }
  }
  
  return { nodes, edges };
}

/**
 * Parse an XML node recursively
 */
function parseNodeRecursive(
  element: Element,
  x: number,
  y: number,
  depth: number,
  variables: Variable[],
  firstSetBlackboardPerVariable: Map<string, Element>
): {
  node: Node | null;
  edges: Edge[];
  allNodes: Node[]; // Include all descendant nodes
} {
  const edges: Edge[] = [];
  const allNodes: Node[] = [];
  let nodeType = element.tagName;
  
  // Handle SubTree nodes
  if (nodeType === 'SubTree') {
    const subtreeId = element.getAttribute('ID') || 'UnnamedSubTree';
    const node = createSubTreeNode(element, subtreeId, x, y);
    return { node, edges, allNodes: [node] };
  }
  
  // Check if this is a SetBlackboard that should be converted to DeclareVariable
  let isDeclareVariable = false;
  if (nodeType === 'SetBlackboard') {
    const outputKey = element.getAttribute('output_key');
    if (outputKey && firstSetBlackboardPerVariable.get(outputKey) === element) {
      // This is the first SetBlackboard for this variable - treat as DeclareVariable
      isDeclareVariable = true;
      nodeType = 'DeclareVariable';
      
      // Add variable to the variables list
      const value = element.getAttribute('value') || '';
      variables.push({ name: outputKey, value });
    }
  }
  
  // Create node from element
  const nodeId = `${nodeType}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  const category = inferNodeCategory(isDeclareVariable ? 'SetBlackboard' : nodeType);
  
  // Extract name attribute if present
  const nodeName = element.getAttribute('name') || undefined;
  
  // Parse attributes as fields
  const fields: any[] = [];
  Array.from(element.attributes).forEach(attr => {
    if (attr.name === 'ID' || attr.name === 'name') return; // Skip ID and name attributes
    
    const value = attr.value;
    let valueType: 'literal' | 'variable' = 'literal';
    let parsedValue: string | number | boolean = value;
    
    // Check if it's a variable reference {varName}
    const varMatch = value.match(/^\{(.+)\}$/);
    if (varMatch) {
      valueType = 'variable';
      parsedValue = varMatch[1];
    } else {
      // Try to parse as number or boolean
      if (!isNaN(Number(value))) {
        parsedValue = Number(value);
      } else if (value === 'true' || value === 'false') {
        parsedValue = value === 'true';
      }
    }
    
    // Add brackets to output_key for SetBlackboard/DeclareVariable for display purposes
    let displayValue = parsedValue;
    if (attr.name === 'output_key' && (nodeType === 'SetBlackboard' || nodeType === 'DeclareVariable')) {
      displayValue = `{${parsedValue}}`;
    }
    
    fields.push({
      name: attr.name,
      type: typeof parsedValue === 'number' ? 'number' : typeof parsedValue === 'boolean' ? 'boolean' : 'string',
      valueType,
      value: displayValue,
    });
  });
  
  const node: Node = {
    id: nodeId,
    type: 'btNode',
    position: { x, y },
    data: {
      id: nodeType.toLowerCase(),
      type: nodeType,
      category,
      name: isDeclareVariable ? 'Declare Variable' : nodeType,
      description: isDeclareVariable ? 'Declares a variable with an initial value (first assignment)' : `${nodeType} node`,
      fields,
      nodeName, // Include custom name if present
      instanceId: nodeId,
      color: getCategoryColorByCategory(category),
    },
  };
  
  allNodes.push(node);
  
  // Parse children
  const children = Array.from(element.children);
  const childSpacing = 200;
  const totalWidth = children.length * childSpacing;
  let childX = x - totalWidth / 2 + childSpacing / 2;
  const childY = y + 100;
  
  children.forEach((child) => {
    const result = parseNodeRecursive(
      child,
      childX,
      childY,
      depth + 1,
      variables,
      firstSetBlackboardPerVariable
    );
    
    if (result.node) {
      // Add edge from current node to child
      edges.push({
        id: `${nodeId}-${result.node.id}`,
        source: nodeId,
        target: result.node.id,
      });
      // Collect all nodes from child subtree
      allNodes.push(...result.allNodes);
      // Collect all edges from child subtree
      edges.push(...result.edges);
    }
    
    childX += childSpacing;
  });
  
  return { node, edges, allNodes };
}

/**
 * Create a SubTree node from XML element
 */
function createSubTreeNode(element: Element, subtreeId: string, x: number, y: number): Node {
  const nodeId = `SubTree_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  
  // Extract name attribute if present
  const nodeName = element.getAttribute('name') || undefined;
  
  // Parse port mappings from attributes
  const fields: any[] = [];
  Array.from(element.attributes).forEach(attr => {
    if (attr.name === 'ID' || attr.name === 'name') return;
    
    const value = attr.value;
    let valueType: 'literal' | 'variable' = 'literal';
    let parsedValue: string | number | boolean = value;
    
    const varMatch = value.match(/^\{(.+)\}$/);
    if (varMatch) {
      valueType = 'variable';
      parsedValue = varMatch[1];
    } else {
      if (!isNaN(Number(value))) {
        parsedValue = Number(value);
      } else if (value === 'true' || value === 'false') {
        parsedValue = value === 'true';
      }
    }
    
    fields.push({
      name: attr.name,
      type: typeof parsedValue === 'number' ? 'number' : typeof parsedValue === 'boolean' ? 'boolean' : 'string',
      valueType,
      value: parsedValue,
    });
  });
  
  return {
    id: nodeId,
    type: 'btNode',
    position: { x, y },
    data: {
      id: subtreeId.toLowerCase(),
      type: subtreeId,
      category: 'subtree',
      name: subtreeId,
      description: `SubTree: ${subtreeId}`,
      fields,
      subtreeId,
      nodeName, // Include custom name if present
      instanceId: nodeId,
      color: '#00BCD4',
    },
  };
}

/**
 * Infer node category from node type
 */
function inferNodeCategory(nodeType: string): 'action' | 'condition' | 'control' | 'decorator' {
  // Control nodes
  const controlNodes = ['Sequence', 'Fallback', 'Parallel', 'ReactiveSequence', 'ReactiveFallback'];
  if (controlNodes.includes(nodeType)) return 'control';
  
  // Decorator nodes
  const decoratorNodes = ['Inverter', 'Retry', 'Repeat', 'Timeout', 'ForceSuccess', 'ForceFailure'];
  if (decoratorNodes.includes(nodeType)) return 'decorator';
  
  // Condition nodes (heuristic: starts with Check, Is, Has)
  if (nodeType.startsWith('Check') || nodeType.startsWith('Is') || nodeType.startsWith('Has')) {
    return 'condition';
  }
  
  // Default to action
  return 'action';
}

/**
 * Get category color
 */
function getCategoryColorByCategory(category: string): string {
  switch (category) {
    case 'root': return '#F44336';
    case 'action': return '#4CAF50';
    case 'condition': return '#2196F3';
    case 'control': return '#FF9800';
    case 'decorator': return '#9C27B0';
    case 'subtree': return '#00BCD4';
    default: return '#757575';
  }
}

/**
 * Escape special XML characters
 */
function escapeXML(str: string): string {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;');
}

/**
 * Parse TreeNodesModel section to extract port definitions for subtrees
 */
function parseTreeNodesModel(root: Element): Map<string, import('../types').SubTreePort[]> {
  const portDefinitions = new Map<string, import('../types').SubTreePort[]>();
  
  const treeNodesModel = root.querySelector('TreeNodesModel');
  if (!treeNodesModel) {
    return portDefinitions;
  }
  
  // Find all SubTree definitions in TreeNodesModel
  const subtreeModels = treeNodesModel.querySelectorAll('SubTree');
  subtreeModels.forEach((subtreeModel) => {
    const subtreeId = subtreeModel.getAttribute('ID');
    if (!subtreeId) return;
    
    const ports: import('../types').SubTreePort[] = [];
    
    // Parse input ports
    const inputPorts = subtreeModel.querySelectorAll('input_port');
    inputPorts.forEach((portElement) => {
      const name = portElement.getAttribute('name');
      if (!name) return;
      
      const typeAttr = portElement.getAttribute('type') as 'string' | 'number' | 'boolean' | null;
      const defaultValue = portElement.getAttribute('default') || undefined;
      const description = portElement.textContent || undefined;
      const required = portElement.getAttribute('required') === 'true';
      
      ports.push({
        name,
        direction: 'input',
        type: typeAttr || 'string',
        defaultValue,
        description,
        required,
      });
    });
    
    // Parse output ports
    const outputPorts = subtreeModel.querySelectorAll('output_port');
    outputPorts.forEach((portElement) => {
      const name = portElement.getAttribute('name');
      if (!name) return;
      
      const typeAttr = portElement.getAttribute('type') as 'string' | 'number' | 'boolean' | null;
      const defaultValue = portElement.getAttribute('default') || undefined;
      const description = portElement.textContent || undefined;
      const required = portElement.getAttribute('required') === 'true';
      
      ports.push({
        name,
        direction: 'output',
        type: typeAttr || 'string',
        defaultValue,
        description,
        required,
      });
    });
    
    // Parse inout ports
    const inoutPorts = subtreeModel.querySelectorAll('inout_port');
    inoutPorts.forEach((portElement) => {
      const name = portElement.getAttribute('name');
      if (!name) return;
      
      const typeAttr = portElement.getAttribute('type') as 'string' | 'number' | 'boolean' | null;
      const defaultValue = portElement.getAttribute('default') || undefined;
      const description = portElement.textContent || undefined;
      const required = portElement.getAttribute('required') === 'true';
      
      ports.push({
        name,
        direction: 'inout',
        type: typeAttr || 'string',
        defaultValue,
        description,
        required,
      });
    });
    
    if (ports.length > 0) {
      portDefinitions.set(subtreeId, ports);
    }
  });
  
  return portDefinitions;
}
